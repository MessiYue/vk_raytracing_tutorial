<meta charset="utf-8" lang="en"><style class="fallback">body{visibility:hidden;}</style>
<link rel="stylesheet" href="vkrt_tutorial.css?">
<script> window.markdeepOptions = { tocStyle: "medium" };</script>
By [Martin-Karl Lefrançois](https://devblogs.nvidia.com/author/mlefrancois/), Neil Bickford
   

!!! Tip
    Updated **December 2019**

# NVIDIA Vulkan Ray Tracing Tutorial - Reflections

![](Images/reflections.png)

This is an extension of the Vulkan ray tracing [tutorial](vkrt_tutorial.md.htm).

You can find the related code in the folder "ray_tracing_reflections"

# Setting Up the scene
First, we will create a scene with two reflective planes and a multicolored cube in the center. Change the `helloVk.loadModel` calls in `main()` to
~~~~ C++
  helloVk.loadModel("../media/scenes/cube.obj",
                    glm::translate(glm::vec3(-2, 0, 0)) * glm::scale(glm::vec3(.1f, 5.f, 5.f)));
  helloVk.loadModel("../media/scenes/cube.obj",
                    glm::translate(glm::vec3(2, 0, 0)) * glm::scale(glm::vec3(.1f, 5.f, 5.f)));
  helloVk.loadModel("../media/scenes/cube_multi.obj");
  helloVk.loadModel("../media/scenes/plane.obj", glm::translate(glm::vec3(0, -1, 0)));
~~~~

Then find `cube.mtl` in `media/scenes` and modify the material to be 95% reflective, without any diffuse
contribution:
~~~~ C++
newmtl  cube_instance_material
illum 3
d 1  
Ns 32 
Ni 0 
Ka 0 0 0
Kd 0 0 0
Ks 0.95 0.95 0.95
~~~~ 



# Recusive Reflections
Vulkan ray tracing allows recursive calls to traceNV, up to a limit defined by 
`VkPhysicalDeviceRayTracingPropertiesNV`. 

In `createRtPipeline()` in `hello_vulkan.cpp`, bring the maximum recursion depth up to 10, making sure not to exceed the physical device's maximum recursion limit:
~~~~ C++
  rayPipelineInfo.setMaxRecursionDepth(
      std::max(10u, m_rtProperties.maxRecursionDepth));  // Ray depth
~~~~ 

## `raycommon.glsl`
We will need to track the depth and the attenuation of the ray.
In the `hitPayload` struct in `raycommon.glsl`, add the following:
~~~~ C++
  int  depth;
  vec3 attenuation;
~~~~ 

## `raytrace.rgen`
In the ray generation shader, we will initialize all payload values before calling `traceNV`.
~~~~ C++
  prd.depth       = 0;
  prd.hitValue    = vec3(0);
  prd.attenuation = vec3(1.f, 1.f, 1.f);
~~~~

## `raytrace.rchit`
At the end of the closest hit shader, before setting `prd.hitValue`, we need to shoot a ray if the material is reflective.

~~~~ C++
  // Reflection
  if(mat.illum == 3 && prd.depth < 10)
  {
    vec3 origin   = worldPos;
    vec3 rayDir   = reflect(gl_WorldRayDirectionNV, normal);
    prd.attenuation *= mat.specular;

    prd.depth++;
    traceNV(topLevelAS,         // acceleration structure
            gl_RayFlagsNoneNV,  // rayFlags
            0xFF,               // cullMask
            0,                  // sbtRecordOffset
            0,                  // sbtRecordStride
            0,                  // missIndex
            origin,             // ray origin
            0.1,                // ray min range
            rayDir,             // ray direction
            100000.0,           // ray max range
            0                   // payload (location = 0)
    );
    prd.depth--;
  }
~~~~ 

The calculated `hitValue` needs to be accumulated, since the payload is global for the 
entire execution from raygen, so change the last line of `main()` to

~~~~ C++
prd.hitValue += vec3(attenuation * lightIntensity * (diffuse + specular)) * prd.attenuation;
~~~~ 

## `raytrace.rmiss`
Finaly, the miss shader also needs to attenuate its contribution:
~~~~ C++
  prd.hitValue = clearColor.xyz * 0.8 * prd.attenuation;
~~~~ 

## Working, but limited
This is working, but it is limited to the number of recursions the GPU can do, and could also impact
performance. Trying to go over the limit of recursions would eventually generate a device lost error.

# Iterative Reflections
Instead of dispatching new rays from the closest hit shader, we will return the information in the 
payload to shoot new rays if needed.

## 'raycommon.glsl'
Enhance the structure to add information to start new rays if wanted.
~~~~ C++
  int  done;
  vec3 rayOrigin;
  vec3 rayDir;
~~~~

## `raytrace.rgen`
Initialize the new members of the payload:
~~~~ C++
  prd.done        = 1;
  prd.rayOrigin   = origin.xyz;
  prd.rayDir      = direction.xyz;
~~~~ 

Instead of calling traceNV only once, we will call it in a loop until we are done. 

Wrap the trace call in `raytrace.rgen` like this:
~~~~ C++
  vec3 hitValue = vec3(0);
  for(;;)
  {
    traceNV( /*.. */);

    hitValue += prd.hitValue * prd.attenuation;

    prd.depth++;
    if(prd.done == 1 || prd.depth >= 10)
      break;

    origin.xyz    = prd.rayOrigin;
    direction.xyz = prd.rayDir;
	prd.done      = 1; // Will stop if a reflective material isn't hit
  }
~~~~

And make sure to write the correct value
~~~~ C++
imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(hitValue, 1.0));
~~~~


## `raytrace.rchit`
We no longer need to shoot rays from the closest hit shader, so we can replace the block at the end with

~~~~ C++
  if(mat.illum == 3)
  {
    vec3 origin = worldPos;
    vec3 rayDir = reflect(gl_WorldRayDirectionNV, normal);
    prd.attenuation *= mat.specular;
    prd.done      = 0;
    prd.rayOrigin = origin;
    prd.rayDir    = rayDir;
  }
~~~~

The calculation of the hitValue also no longer needs to be additive, or take attenuation into account:
~~~~ C++
  prd.hitValue = vec3(attenuation * lightIntensity * (diffuse + specular));
~~~~ 

## `raytrace.rmiss`
Since the ray generation shader now handles attenuation, we no longer need to attenuate the value returned in the miss shader:
~~~~ C++
  prd.hitValue = clearColor.xyz * 0.8;
~~~~ 

## Max Recursion 
Finally, we no longer need to have a deep recursion setting in `createRtPipeline` -- just a depth of 2, one for the initial ray generation segment and another for shadow rays.
~~~~ C++
  rayPipelineInfo.setMaxRecursionDepth(2);  // Ray depth
~~~~

In `raytrace.rgen`, we can now make the maximum ray depth significantly larger -- such as 100, for instance -- without causing a device lost error.


<!-- Markdeep: -->
<script src="https://developer.nvidia.com/sites/default/files/akamai/gameworks/whitepapers/markdeep.min.js"></script>
<script>window.alreadyProcessedMarkdeep || (document.body.style.visibility = "visible")</script>